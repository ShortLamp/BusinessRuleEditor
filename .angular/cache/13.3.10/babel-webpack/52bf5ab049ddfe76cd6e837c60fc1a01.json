{"ast":null,"code":"import { coerceElement } from '@angular/cdk/coercion';\nimport { DropListRef } from '@angular/cdk/drag-drop';\nexport function installPatch() {\n  DropListRef.prototype._getSiblingContainerFromPosition = function (item, x, y) {\n    // Possible targets include siblings and 'this'\n    let targets = [this, ...this._siblings];\n    // Only consider targets where the drag postition is within the client rect\n    // (this avoids calling enterPredicate on each possible target)\n    let matchingTargets = targets.filter(ref => {\n      return ref._clientRect && isInsideClientRect(ref._clientRect, x, y);\n    });\n    // Stop if no targets match the coordinates\n    if (matchingTargets.length == 0) {\n      return undefined;\n    }\n    // Order candidates by DOM hierarchy and z-index\n    let orderedMatchingTargets = orderByHierarchy(matchingTargets);\n    // The drop target is the last matching target in the list\n    let matchingTarget = orderedMatchingTargets[orderedMatchingTargets.length - 1];\n    // Only return matching target if it is a sibling\n    if (matchingTarget === this) {\n      return undefined;\n    }\n    // Can the matching target receive the item?\n    if (!matchingTarget._canReceive(item, x, y)) {\n      return undefined;\n    }\n    // Return matching target\n    return matchingTarget;\n  };\n}\n// Not possible to improt isInsideClientRect from @angular/cdk/drag-drop/client-rect\nfunction isInsideClientRect(clientRect, x, y) {\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = clientRect;\n  return y >= top && y <= bottom && x >= left && x <= right;\n}\n// Order a list of DropListRef so that for nested pairs, the outer DropListRef\n// is preceding the inner DropListRef. Should probably be ammended to also\n// sort by Z-level.\nfunction orderByHierarchy(refs) {\n  // Build a map from HTMLElement to DropListRef\n  let refsByElement = new Map();\n  refs.forEach(ref => {\n    refsByElement.set(coerceElement(ref.element), ref);\n  });\n  // Function to identify the closest ancestor among th DropListRefs\n  let findAncestor = ref => {\n    let ancestor = coerceElement(ref.element).parentElement;\n    while (ancestor) {\n      if (refsByElement.has(ancestor)) {\n        return refsByElement.get(ancestor);\n      }\n      ancestor = ancestor.parentElement;\n    }\n    return undefined;\n  };\n  // Add all refs as nodes to the tree\n  let tree = new Map();\n  refs.forEach(ref => {\n    tree.set(ref, {\n      ref: ref,\n      children: []\n    });\n  });\n  // Build parent-child links in tree\n  refs.forEach(ref => {\n    let parent = findAncestor(ref);\n    if (parent) {\n      let node = tree.get(ref);\n      let parentNode = tree.get(parent);\n      node.parent = parentNode;\n      parentNode.children.push(node);\n    }\n  });\n  // Find tree roots\n  let roots = Array.from(tree.values()).filter(node => !node.parent);\n  // Function to recursively build ordered list from roots and down\n  let buildOrderedList = (nodes, list) => {\n    list.push(...nodes.map(node => node.ref));\n    nodes.forEach(node => {\n      buildOrderedList(node.children, list);\n    });\n  };\n  // Build and return the ordered list\n  let ordered = [];\n  buildOrderedList(roots, ordered);\n  return ordered;\n}","map":null,"metadata":{},"sourceType":"module"}